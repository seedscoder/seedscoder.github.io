[{"title":"Mac M1 CLion 编译 Hotspot","url":"/2024/01/11/Mac-M1-CLion-%E7%BC%96%E8%AF%91Hotspot/","content":"环境信息\n系统：Mac M1 14.2.1 \n\nxcode 版本： \n\nxcodebuild -version\n\n\n\nXcode 15.0.1Build version 15A507\n\n\n\n\n\n准备代码从 GitHub 将 jdk 源码 clion 克隆至本地 (  $JDK_SOURCE_CODE_DIR )\ngit clone https://github.com/openjdk/jdk.git\n\n\n\n\n\n编译 jdk 源码\n进入  $JDK_SOURCE_CODE_DIR/jdk ，执行一下命令\n\n\nconfigure –disable-warnings-as-errors –with-debug-level&#x3D;slowdebug –with-jvm-variants&#x3D;server\n\n控制台报错提示：configure  没有执行权限，运行以下命令即可，修改 configure  文件对应权限之后，再次运行编译命令\n\nchmod +x configure\n\n\nconfigure –disable-warnings-as-errors –with-debug-level&#x3D;slowdebug –with-jvm-variants&#x3D;server\n\n控制台报错提示：缺少 autoconf  ，此时执行控制台提示的安装命令即可，安装成功之后，再次执行命令，成功。\n\nbrew install autoconf\n\n\n.&#x2F;configure –disable-warnings-as-errors –with-debug-level&#x3D;slowdebug –with-jvm-variants&#x3D;server\n\n* C++ Compiler:   Version 15.0.0 (at /usr/bin/clang++ -std=gnu++11)Build performance summary:* Build jobs:     10* Memory limit:   32768 MB\n\n\n\n\nmake images\n\n\n出现如下错误\n\nBuilding target &#x27;images&#x27; in configuration &#x27;macosx-aarch64-server-slowdebug&#x27;Compiling up to 1 files for BUILD_TOOLS_HOTSPOTCompiling up to 8 files for BUILD_TOOLS_LANGTOOLSxattr: [Errno 13] Permission denied: &#x27;/Users/me/workspace/open-source/jdk/build/macosx-aarch64-server-slowdebug/jdk/conf/management/jmxremote.password.template&#x27;make[3]: *** [/Users/me/workspace/open-source/jdk/build/macosx-aarch64-server-slowdebug/jdk/conf/management/jmxremote.password.template] Error 1make[3]: *** Deleting file `/Users/me/workspace/open-source/jdk/build/macosx-aarch64-server-slowdebug/jdk/conf/management/jmxremote.password.template&#x27;make[3]: *** Waiting for unfinished jobs....make[2]: *** [jdk.management.agent-copy] Error 2make[2]: *** Waiting for unfinished jobs....ERROR: Build failed for target &#x27;images&#x27; in configuration &#x27;macosx-aarch64-server-slowdebug&#x27; (exit code 2)No indication of failed target found.HELP: Try searching the build log for &#x27;] Error&#x27;.HELP: Run &#x27;make doctor&#x27; to diagnose build problems.make[1]: *** [main] Error 2make: *** [images] Error 2\n\n\n\n\n解决办法：\n删除   $JDK_SOURCE_CODE_DIR/jdk/build 目录。换用系统自带的 terminal，再次执行 make images\n\n\n\n\nhttps://bugs.openjdk.org/browse/JDK-8299148?page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel&amp;showAll=true\n\n编译成功之后的会出现如下内容：\nCreating support/demos/image/jfc/Font2DTest/Font2DTest.jarCreating support/demos/image/jfc/J2Ddemo/J2Ddemo.jarCreating support/demos/image/jfc/SwingSet2/SwingSet2.jarCreating support/demos/image/jfc/Metalworks/Metalworks.jarCreating support/demos/image/jfc/Notepad/Notepad.jarCreating support/demos/image/jfc/Stylepad/Stylepad.jarCreating support/demos/image/jfc/SampleTree/SampleTree.jarCreating support/demos/image/jfc/TableExample/TableExample.jarCreating support/demos/image/jfc/TransparentRuler/TransparentRuler.jarCompiling up to 2 files for CLASSLIST_JARCreating support/classlist.jarCreating jdk.jlink.jmodCreating java.base.jmodCreating jdk imageCreating CDS archive for jdk image for serverCreating CDS-NOCOOPS archive for jdk image for serverStopping javac serverFinished building target &#x27;images&#x27; in configuration &#x27;macosx-aarch64-server-slowdebug&#x27;\n\n\n\n\n\n验证进入  $JDK_SOURCE_CODE_DIR/jdk/build/macosx-aarch64-server-slowdebug/jdk/bin 目录，执行以下命令\n\n.&#x2F;java -version\n\n输出如下内容：\nopenjdk version &quot;23-internal&quot; 2024-09-17OpenJDK Runtime Environment (slowdebug build 23-internal-adhoc.me.jdk)OpenJDK 64-Bit Server VM (slowdebug build 23-internal-adhoc.me.jdk, mixed mode)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["JVM","编译"],"tags":["技术","Hotspot"]},{"title":"Spring-Boot-启动流程","url":"/2023/12/22/Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","content":"\nSpring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.\n\n","categories":["Spring Boot","源码"],"tags":["技术"]},{"title":"Spring Cloud Alibaba Nacos 服务配置原理解析","url":"/2023/12/18/Spring-Cloud-Alibaba-Nacos-%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","content":"\nNacos : 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 \n\n","categories":["Spring Cloud Alibaba","Nacos","源码"],"tags":["技术"]},{"title":"Spring MVC 之 DispatcherServlet 请求处理逻辑","url":"/2023/12/26/Spring-MVC-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/","content":"组件简介DispatcherServlet 是 Spring MVC 中的核心组件，它会拦截符合特定规则的请求并将其分发到对应的处理器（Controller）进行处理。\nSpring MVC在 Spring MVC 应用配置文件中，可以看到以下配置：\n&lt;!-- 配置 DispatcherServlet --&gt;&lt;servlet&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- 配置 DispatcherServlet 的配置文件位置 --&gt;    &lt;init-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;/WEB-INF/spring-mvc-config.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!-- 映射 DispatcherServlet 拦截的 URL --&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;\n\n\n\n\n\n\n\nSpring Bootorg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration\n@Configuration(proxyBeanMethods = false)@Conditional(DispatcherServletRegistrationCondition.class)@ConditionalOnClass(ServletRegistration.class)@EnableConfigurationProperties(WebMvcProperties.class)@Import(DispatcherServletConfiguration.class)protected static class DispatcherServletRegistrationConfiguration &#123;\t@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)\t@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)\tpublic DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,\t\t\tWebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) &#123;          // 跟踪 webMvcProperties.getServlet().getPath() ，这段代码，会发现，path 的默认值是： / ，代表拦截所有请求\t\tDispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,\t\t\t\twebMvcProperties.getServlet().getPath());     \t\tregistration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);\t\tregistration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());\t\tmultipartConfig.ifAvailable(registration::setMultipartConfig);\t\treturn registration;\t&#125;&#125;\n\n\n\n准备阶段​         根据DispatcherServlet 继承体系，可以看出它其实是一个 Servlet ，所以自己实例会有自己的生命周期，init 便是其中比较重要的用于初始化组件的方法。\n@Overridepublic final void init() throws ServletException &#123;\t// Set bean properties from init parameters.\t......\t// Let subclasses do whatever initialization they like.\tinitServletBean();&#125;\n\n\n\n@Override\tprotected final void initServletBean() throws ServletException &#123;    ......\t\ttry &#123;\t\t\tthis.webApplicationContext = initWebApplicationContext();\t\t\tinitFrameworkServlet();\t\t&#125;\t\tcatch (ServletException | RuntimeException ex) &#123;\t\t\tlogger.error(&quot;Context initialization failed&quot;, ex);\t\t\tthrow ex;\t\t&#125;        ......\t&#125;\n\n\n\nprotected WebApplicationContext initWebApplicationContext() &#123;\t\tWebApplicationContext rootContext =\t\t\t\tWebApplicationContextUtils.getWebApplicationContext(getServletContext());\t\t\t\tif (!this.refreshEventReceived) &#123;\t\t\t// Either the context is not a ConfigurableApplicationContext with refresh\t\t\t// support or the context injected at construction time had already been\t\t\t// refreshed -&gt; trigger initial onRefresh manually here.\t\t\t      synchronized (this.onRefreshMonitor) &#123;\t\t\t\tonRefresh(wac);\t\t\t&#125;\t\t&#125;      ......  \t\treturn wac;\t&#125;\n\n\n\n\n\n@Overrideprotected void onRefresh(ApplicationContext context) &#123;\tinitStrategies(context);&#125;/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123;\tinitMultipartResolver(context);\tinitLocaleResolver(context);\tinitThemeResolver(context);\t   // 以下两个组件的逻辑差不多，都是把 IOC 容器中的 Bean（HandlerMapping / HandlerAdapter ）放到 DispatcherServlet 字段中   initHandlerMappings(context);\tinitHandlerAdapters(context);\t   initHandlerExceptionResolvers(context);\tinitRequestToViewNameTranslator(context);\tinitViewResolvers(context);\tinitFlashMapManager(context);&#125;\n\n\n\n至于是何时把  HandlerMapping &#x2F; HandlerAdapter  这两种组件加入 IOC 容器中，可以 阅读 EnableWebMvc 注解 及其 相关的类\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123;&#125;\n\n\n\n@Configuration(proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;&#125;\n\n\n\n// 从 WebMvcConfigurationSupport 类中，我们看到 注入了Spring MVC 运行需要的各种组件 @Bean@SuppressWarnings(&quot;deprecation&quot;)public RequestMappingHandlerMapping requestMappingHandlerMapping(\t\t@Qualifier(&quot;mvcContentNegotiationManager&quot;) ContentNegotiationManager contentNegotiationManager,\t\t@Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService,\t\t@Qualifier(&quot;mvcResourceUrlProvider&quot;) ResourceUrlProvider resourceUrlProvider) &#123;&#125;@Bean@Nullablepublic HandlerMapping viewControllerHandlerMapping(\t\t@Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService,\t\t@Qualifier(&quot;mvcResourceUrlProvider&quot;) ResourceUrlProvider resourceUrlProvider) &#123;&#125;/** * Return a &#123;@link BeanNameUrlHandlerMapping&#125; ordered at 2 to map URL * paths to controller bean names. */@Beanpublic BeanNameUrlHandlerMapping beanNameHandlerMapping(\t\t@Qualifier(&quot;mvcConversionService&quot;) FormattingConversionService conversionService,\t\t@Qualifier(&quot;mvcResourceUrlProvider&quot;) ResourceUrlProvider resourceUrlProvider) &#123;&#125;.....  \n\n\n\n\n以上便是，DispatchServlet  在接收请求之前的初始化逻辑，主要就是完成组件的初始化，注入响应的属性，方便后续流程。\n\n接收请求DispatchServlet 处理 流程的大致框架如下所示，后面仔细分析\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  try &#123;    try &#123;      // Determine handler for the current request.      // 1、根据请求路径，匹配 controller 中的 handler 方法，以及 查找本次请求需要执行的 拦截器列表，组成一个 HandlerExecutionChain      mappedHandler = getHandler(processedRequest);      if (mappedHandler == null) &#123;        // 1、1 如果 没有 匹配的 handler ，此时需要根据情况判断是 直接抛出异常，还是转发到其他页面        noHandlerFound(processedRequest, response);        return;      &#125;      // Determine handler adapter for the current request.      // 2、 找到 HandlerAdapter ，从准备阶段可以看出，此时IOC 容器中 可能是有多个 HandlerAdapter ，具体由哪个执行，需要根据 HandlerAdapter 的 support 方法确定      HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());      // 3、 执行 HandlerInterceptor 的 preHandle 方法      if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;        return;      &#125;      // Actually invoke the handler.      // 4、 执行方法，这其中包含 请求参数的处理（比如：url 后面的拼接的参数转换成 pojo 类， @PathVariable / @RequestBody 等等注解的处理）      mv = ha.handle(processedRequest, response, mappedHandler.getHandler());      // 5 、 执行 HandlerInterceptor 的 postHandle 方法      mappedHandler.applyPostHandle(processedRequest, response, mv);    &#125;    // 6.1 、 handler 被正常执行，执行 HandlerInterceptor 的 afterCompletion 方    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);  &#125; catch (Exception ex) &#123;    // 6.2 、 如果执行过程中出现异常，执行 HandlerInterceptor 的 afterCompletion 方法    triggerAfterCompletion(processedRequest, response, mappedHandler, ex);  &#125; catch (Throwable err) &#123;    //  6.3 、 同上    triggerAfterCompletion(processedRequest, response, mappedHandler,        new ServletException(&quot;Handler processing failed: &quot; + err, err));  &#125; finally &#123;  &#125;&#125;\n\n\n\n\n\nHandlerExecutionChainprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;\tif (this.handlerMappings != null) &#123;\t\tfor (HandlerMapping mapping : this.handlerMappings) &#123;\t\t\tHandlerExecutionChain handler = mapping.getHandler(request);\t\t\tif (handler != null) &#123;\t\t\t\treturn handler;\t\t\t&#125;\t\t&#125;\t&#125;\treturn null;&#125;\n\n\n\n\n\nHandlerAdapterprotected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException &#123;\tif (this.handlerAdapters != null) &#123;\t\tfor (HandlerAdapter adapter : this.handlerAdapters) &#123;\t\t\tif (adapter.supports(handler)) &#123;\t\t\t\treturn adapter;\t\t\t&#125;\t\t&#125;\t&#125;\tthrow new ServletException(&quot;No adapter for handler [&quot; + handler +\t\t\t&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);&#125;\n\n\n\n\n\n准备执行目标方法public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;   // 1、 准备调用 handler 方法\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\tsetResponseStatus(webRequest);\tif (returnValue == null) &#123;\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123;\t\t\tdisableContentCachingIfNecessary(webRequest);\t\t\tmavContainer.setRequestHandled(true);\t\t\treturn;\t\t&#125;\t&#125;\telse if (StringUtils.hasText(getResponseStatusReason())) &#123;\t\tmavContainer.setRequestHandled(true);\t\treturn;\t&#125;\tmavContainer.setRequestHandled(false);\tAssert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);\ttry &#123;     // 2、 处理结果\t\tthis.returnValueHandlers.handleReturnValue(\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\t&#125;\tcatch (Exception ex) &#123;\t\tif (logger.isTraceEnabled()) &#123;\t\t\tlogger.trace(formatErrorForReturnValue(returnValue), ex);\t\t&#125;\t\tthrow ex;\t&#125;&#125;\n\n\n\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\tObject... providedArgs) throws Exception &#123;   // 1.1、 处理请求参数\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\tif (logger.isTraceEnabled()) &#123;\t\tlogger.trace(&quot;Arguments: &quot; + Arrays.toString(args));\t&#125;      // 1.2、 通过反射调用 handler 方法\treturn doInvoke(args);&#125;\n\n\n\n\n\n处理参数信息protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\t\t\tObject... providedArgs) throws Exception &#123;\t\tMethodParameter[] parameters = getMethodParameters();\t\tif (ObjectUtils.isEmpty(parameters)) &#123;\t\t\treturn EMPTY_ARGS;\t\t&#125;\t\tObject[] args = new Object[parameters.length];\t\tfor (int i = 0; i &lt; parameters.length; i++) &#123;\t\t\tMethodParameter parameter = parameters[i];\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\t\t\targs[i] = findProvidedArgument(parameter, providedArgs);\t\t\tif (args[i] != null) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\tif (!this.resolvers.supportsParameter(parameter)) &#123;\t\t\t\tthrow new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));\t\t\t&#125;\t\t\ttry &#123;\t\t\t\targs[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\t\t\t&#125;\t\t\tcatch (Exception ex) &#123;\t\t\t\t// Leave stack trace for later, exception may actually be resolved and handled...\t\t\t\tif (logger.isDebugEnabled()) &#123;\t\t\t\t\tString exMsg = ex.getMessage();\t\t\t\t\tif (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;\t\t\t\t\t\tlogger.debug(formatArgumentError(parameter, exMsg));\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t\tthrow ex;\t\t\t&#125;\t\t&#125;\t\treturn args;\t&#125;\n\n\n\n\n\n\n\n反射执行 handler 方法protected Object doInvoke(Object... args) throws Exception &#123;\t\tMethod method = getBridgedMethod();\t\ttry &#123;\t\t\tif (KotlinDetector.isSuspendingFunction(method)) &#123;\t\t\t\treturn invokeSuspendingFunction(method, getBean(), args);\t\t\t&#125;\t\t\treturn method.invoke(getBean(), args);\t\t&#125;\t\t......\t\t&#125;\t&#125;\n\n\n\n处理响应结果public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\tif (handler == null) &#123;\t\tthrow new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());\t&#125;\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125;\n\n\n\n\n\n\n\n","categories":["Spring MVC","源码"],"tags":["技术","JAVA"]},{"title":"Hello World","url":"/2024/01/12/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]